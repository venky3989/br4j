/**
 *   Licensed to the Apache Software Foundation (ASF) under one or more
 *   contributor license agreements.  See the NOTICE file distributed with
 *   this work for additional information regarding copyright ownership.
 *   The ASF licenses this file to you under the Apache License, Version 2.0
 *   (the "License"); you may not use this file except in compliance with
 *   the License.  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.io.*;
import org.tmatesoft.svn.core.wc.*;
import org.tmatesoft.svn.core.auth.*;
import org.gradle.logging.internal.*;
import org.apache.commons.io.input.*;
import org.apache.commons.io.IOUtils;
import java.security.MessageDigest;
import java.net.*;

buildscript {
    apply from: 'dependencies.gradle', to: buildscript
}

//параметры используемые во время исполнения скрипта (генерятся из входных параметров gradle)
apply from: "variables.gradle"

int i = 1
ext.remoteHosts = []
while (project.hasProperty("remote${i}.remoteHost") || env["remote${i}.remoteHost"]) {
    def host = [:]
    host['remoteHost']     = env["remote${i}.remoteHost"]     ?: (project["remote${i}.remoteHost"])
    host['remoteUser']     = env["remote${i}.remoteUser"]     ?: (project["remote${i}.remoteUser"])
    host['remotePass']     = env["remote${i}.remotePass"]     ?: (project.hasProperty("remote${i}.remotePass") ? project["remote${i}.remotePass"] : null)
    host['keyfile']        = env["remote${i}.keyfile"]        ?: (project.hasProperty("remote${i}.keyfile")    ? project["remote${i}.keyfile"]    : null)
    host['remoteJBossDir'] = env["remote${i}.remoteJBossDir"] ?: (project["remote${i}.remoteJBossDir"])
    host['deployScript']   = env["remote${i}.deployScript"]   ?: (project["remote${i}.deployScript"  ])
    host['vpnUp']          = env["remote${i}.vpnUp"]          ?: (project.hasProperty("remote${i}.vpnUp")    ? project["remote${i}.vpnUp"]    : null)
    host['vpnDown']        = env["remote${i}.vpnDown"]        ?: (project.hasProperty("remote${i}.vpnDown")  ? project["remote${i}.vpnDown"]  : null)
    host['startCmd']       = env["remote${i}.startCmd"]       ?: (project.hasProperty("remote${i}.startCmd") ? project["remote${i}.startCmd"] : null)
    host['stopCmd']        = env["remote${i}.stopCmd"]        ?: (project.hasProperty("remote${i}.stopCmd")  ? project["remote${i}.stopCmd"]  : null)
    host['startTimeout']   = env["remote${i}.startTimeout"]   ?: (project.hasProperty("remote${i}.startTimeout") ? project["remote${i}.startTimeout"]  : 300)
    host['checkTimeout']   = env["remote${i}.checkTimeout"]   ?: (project.hasProperty("remote${i}.checkTimeout") ? project["remote${i}.checkTimeout"]  : 20)
    host['jndiPort']       = env["remote${i}.jndiPort"]       ?: (project.hasProperty("remote${i}.jndiPort")     ? project["remote${i}.jndiPort"]      : 1099)
    remoteHosts << host
    i++
}

remoteHosts.eachWithIndex { host, index ->
    print "remote${index+1}: "
    println host.findAll { field ->
        field.value != null
    }

    if (!host.remotePass && !host.keyfile) {
        throw new IllegalArgumentException("Не заданы пароль или ключ для ssh доступа к 'remote${index}'")
    }
    if (host.vpnUp && !host.vpnDown) {
        throw new IllegalArgumentException("Задана команда включения VPN, но не задана команда отключения VPN")
    }
}

ext.getShortVersion = { url=releaseSvnUrl ->
    def svnRepository = clientManager.createRepository(url, false)
    def props = new SVNProperties()
    svnRepository.getDir(".", -1, props, (Collection)null)
    def version = SVNPropertyValue.getPropertyAsString(props.getSVNPropertyValue(br4jVersionProp))
    if (!version) {
        version = br4jAppVersion
    }
    println "App Version = ${version}"
    return version
}

//получить мапу (URL -> revision) содержимого по URL в SVN, начинающегося на указанный префикс
//modes:
//  0 - depth=immediate, svnKind=all
//  1 - depth=infinity,  svnKind=files
ext.getSvnList = { url, rev=-1, prefix='', mode=0 ->
    def map = [:]
    SVNRevision svnRev = rev == -1 ? SVNRevision.HEAD : SVNRevision.create(rev)
    def depth = mode == 0 ? SVNDepth.IMMEDIATES : SVNDepth.INFINITY
    clientManager.logClient.doList(
        //params: url, pegRevision, revision, fetchLocks, depth, entryFields, handler
        url, SVNRevision.UNDEFINED, svnRev, true, depth, SVNDirEntry.DIRENT_ALL, 
        { dirEntry ->
            def path = dirEntry.relativePath
            if (path && path.startsWith(prefix)) {
                if (mode == 0 || (mode == 1 && dirEntry.kind == SVNNodeKind.FILE)) {
                    map[path] = dirEntry.revision
                }
            }
        } as ISVNDirEntryHandler
    )
    return map
}

//получить ревизию откуда был создан патч
ext.getPatchRealRevision = { node ->
    def url = SVNURL.parseURIEncoded("${tagReleaseSvnUrl}/${node}")
    Map res = [:]
    def count = 0
    logClient.doLog(url, null, 
                    SVNRevision.UNDEFINED, 
                    SVNRevision.HEAD, 
                    SVNRevision.create(0),
                    false, false, false, 2, null, 
                    { logEntry ->
                        print "\t ${logEntry.revision} (${logEntry.date})"
                        if (++count == 2) {
                            println " - ревизия в release, с которой создали ${node == 'release' ? 'сборку' : 'патч'}"
                            res['release'] = logEntry.revision
                        } else {
                            println ''
                            res['tag'] = logEntry.revision
                        }
                    } as ISVNLogEntryHandler
    )
    return res
}

ext.md5 = { inputFile ->
   MessageDigest digest = MessageDigest.getInstance("MD5")
   inputFile.withInputStream { inputStream ->
        byte[] buffer = new byte[8192]
        int read = 0
        while( (read = inputStream.read(buffer)) > 0) {
            digest.update(buffer, 0, read)
        }
    }
    byte[] md5sum = digest.digest()
    BigInteger bigInt = new BigInteger(1, md5sum)
    bigInt.toString(16).padLeft(32, '0')
}

ext.relativize = { root, full ->
    file(root).toURI().relativize(full.toURI()).path
}

ext.getUrlRevision = { url -> 
    def revision
    def svnRepository = clientManager.createRepository(url, false)
    try {
        revision  = svnRepository?.info(".", -1)?.revision
    } finally {
        svnRepository?.closeSession()
    }
    return revision
}

ext.getIpAddress = {
    def resultIps = []
    def networkInterfaces = NetworkInterface.getNetworkInterfaces()
    networkInterfaces.each { netInterface ->
        if (!netInterface.loopback) {
            println "InetInterface name: ${netInterface.displayName}"
            def addresses = netInterface.inetAddresses
            addresses.each {
                if (netInterface instanceof Inet4Address && !netInterface.loopbackAddress) {
                    println "\taddress: ${netInterface.hostAddress} (${netInterface.hostName})"
                    resultIps << "${netInterface.hostAddress} (${netInterface.hostName})"
                }
            }
        }
    }
    if (!resultIps) {
        println "local address: ${InetAddress.localHost}"
        resultIps << "$InetAddress.localHost"
    }
    return resultIps
}

//удаление пустых папок
def delEmptyDirs(File dir) {
    if (dir.isDirectory()) {
        for (File innerDir : dir.listFiles()) {
            delEmptyDirs(innerDir)
        }
        if (dir.listFiles().size() == 0) {
            dir.deleteDir();
        }
    }
}

//функция определения URL'ов откуда и докуда собирать различия
ext.resolveUrls = { params ->
    def ret = [:]
    def oldProjectTagLocation = false

    if (patchNum) {
        def svnRepo = clientManager.createRepository(tagReleaseBaseSvnUrl, false)
        def checkPath = svnRepo.checkPath(".", -1)
        if (checkPath == SVNNodeKind.NONE) {
            oldProjectTagLocation = true
        }

        ret.repoUrl = "${tagUrl}/${releaseName}/${buildNum}"
        ret.from    = "${ret.repoUrl}/release/${oldProjectTagLocation     ? params.projectUrl         : (params.projectUrl ? 'base/'+params.projectUrl : '')}"
        ret.to      = "${ret.repoUrl}/${patchNum}/${oldProjectTagLocation ? 'base/'+params.projectUrl : (params.projectUrl ? 'base/'+params.projectUrl : '')}"
        ret.between = "${releaseName}.${buildNum}[release-${patchNum}]"
        println " Собираем различия от сборки релиза до указанного патча: ${ret.between}"
    } else if (buildNum) {
        def prevBuildNum = "r01"
        def prevRelease = releases.findAll { it < releaseName }.max()
        if (prevRelease == null) {
            println " Предыдущих релизов нет. Это первый релиз для данного заказчика."

            if (buildNum == "r01") {
                println " Это первая сборка в данном релизе. Не надо собирать различия."
                return null
            } else {
                def svnRepo = clientManager.createRepository(SVNURL.parseURIEncoded("${tagUrl}/${releaseName}/${prevBuildNum}/release/base"), false)
                def checkPath = svnRepo.checkPath(".", -1)
                if (checkPath == SVNNodeKind.NONE) {
                    oldProjectTagLocation = true
                }
                ret.repoUrl = "${tagUrl}/${releaseName}/${buildNum}"
                ret.prevUrl = "${tagUrl}/${releaseName}/${prevBuildNum}/release"
                ret.from    = "${tagUrl}/${releaseName}/${prevBuildNum}/release/${oldProjectTagLocation ? params.projectUrl : (params.projectUrl ? 'base/'+params.projectUrl : '')}"
                ret.to      = "${ret.repoUrl}/release/${oldProjectTagLocation ? 'base/'+params.projectUrl                   : (params.projectUrl ? 'base/'+params.projectUrl : '')}"
                ret.between = "${releaseName}[${prevBuildNum}-${buildNum}]"
                println " Собираем различия с первой сборки текущего релиза: ${ret.between}"
            }
        } else {
            def svnRepo = clientManager.createRepository(SVNURL.parseURIEncoded("${tagUrl}/${prevRelease}/${prevBuildNum}/release/base"), false)
            def checkPath = svnRepo.checkPath(".", -1)
            if (checkPath == SVNNodeKind.NONE) {
                oldProjectTagLocation = true
            }
            ret.repoUrl = "${tagUrl}/${releaseName}/${buildNum}"
            ret.prevUrl = "${tagUrl}/${prevRelease}/${prevBuildNum}/release"
            ret.from    = "${tagUrl}/${prevRelease}/${prevBuildNum}/release/${oldProjectTagLocation ? params.projectUrl : (params.projectUrl ? 'base/'+params.projectUrl : '')}"
            ret.to      = "${ret.repoUrl}/release/${oldProjectTagLocation ? 'base/'+params.projectUrl                   : (params.projectUrl ? 'base/'+params.projectUrl : '')}"
            ret.between = "${prevRelease}[${prevBuildNum}]-${releaseName}[${buildNum}]"
            println " Собираем различия с предыдущего релиза: ${ret.between}"
        }
    } else {
        throw new IllegalArgumentException("Неверный режим сборки изменений: (не заданы ни номер сборки, ни номер патча)")
    }

    //normalizing
    ret.from = new URI(ret.from).normalize().toString()
    ret.to   = new URI(ret.to).normalize().toString()

    return ret
}

//объединение списков файлов, собранных из разных источников в svn
//например из основной ветки и конфигураций
ext.mergeFileMaps = { List maps ->
    Map resultMap = [:]
    Map allArmFiles = [:]
    
    def maxRevision = maps*.keySet()*.max().max()

    maps.each { map ->
        map.each { entryByRev ->
            def revision = entryByRev.key
            Map fileMap  = entryByRev.value
            Map resultPathMap = resultMap[revision] ?: [:]

            fileMap.each { entryByPath ->
                def path = entryByPath.key
                def url  = entryByPath.value
                if (path.startsWith('ARM_Views')) {
                    allArmFiles[path] = url
                } else {
                    resultPathMap[path] = url
                }
            }

            if (resultPathMap) {
                resultMap[revision] = resultPathMap
            }
        }
    }

    //армовские файлы выносим в конец списка
    if (allArmFiles) {
        Map lastEntry = resultMap[maxRevision] ?: [:]
        lastEntry.putAll(allArmFiles)
        resultMap[maxRevision] = lastEntry
    }

    return resultMap
}

//объединение списков доп. файлов, собранных из разных источников в svn
//например из основной ветки и конфигураций
ext.mergeAttachMaps = { List maps ->
    Map resultMap = [:]
    maps.each { map ->
        map.each { entryByPath ->
            def path = entryByPath.key
            def url  = entryByPath.value
            resultMap[path] = url
        }
    }
    return resultMap
}

ext.prepareIuhPackages = {
    def passportPath = "${workspaceBuild}/${updatesBuildDirectory}/${iuhPackagePassport_upd}"

    //фиксированные скрипты (00.Init и тд)
    def iuhUrl = "${buildUrl}/base/${iuhBasePackageDirectory}"
    def svnRepo = clientManager.createRepository(SVNURL.parseURIEncoded(iuhUrl), false)
    def checkPath = svnRepo.checkPath(".", -1)
    if (checkPath == SVNNodeKind.NONE) {
        println "\n===================================================="
        println "${iuhUrl} does not exists. Skipping IUH prepare..."
        println "=====================================================\n"
        return [
            passportPath:   passportPath,
            specialFiles:   [],
            specialFolders: []
        ]
    }

    def packagePassport = file(passportPath)
    packagePassport.parentFile.mkdirs()

    def logFile = file("${logsDir}/checkout_iuh_passports_and_fixed_scripts.log")
    logFile.parentFile.mkdirs()
    logFile.delete()

    //получаем из SVN список имен фикс. пакетов и заготовок паспортов
    Map iuhBaseList = getSvnList(SVNURL.parseURIEncoded(iuhUrl))
    
    List passports = iuhBaseList.findAll { entry ->
        entry.key.endsWith('.id')
    }.collect { entry ->
        entry.key
    }
    List fixedScripts = iuhBaseList.findAll { entry ->
        !passports.contains(entry.key)
    }.collect { entry ->
        entry.key
    }

    println '==Выкачиваем заготовки паспортов (install/update).=='
    passports.each { specialFile ->
        def from = "${iuhUrl}/${specialFile}"
        def to   =  "${workspaceBuild}/${updatesBuildDirectory}/${specialFile}"
        println "\tоткуда: $from"
        println "\t  куда: $to"
        file(to).parentFile.mkdirs()
        def fos = new FileOutputStream(logFile)
        exec {
            executable "svn"
            args "export"
            args "--username", "$svnLogin"
            args "--password", "$svnPass"
            args "--non-interactive"
            args "$from"
            args "$to"
            standardOutput = fos
        }
    }

    println '==Выкачиваем фиксированный набор скриптов.=='
    fixedScripts.each { specialFolder ->
        def from = "${iuhUrl}/${specialFolder}"
        def to   =  "${workspaceBuild}/${updatesBuildDirectory}/${specialFolder}"
        println "\tоткуда: $from"
        println "\t  куда: $to"
        file(to).parentFile.mkdirs()
        def fos = new FileOutputStream(logFile)
        exec {
            executable "svn"
            args "export"
            args "--username", "$svnLogin"
            args "--password", "$svnPass"
            args "--non-interactive"
            args "$from"
            args "$to"
            standardOutput = fos
        }
    }

    //в паспорте install правим первую строчку (имя пакета)
    def content = "${updatesPackageDirectory}\n"
    file("${workspaceBuild}/${updatesBuildDirectory}/${iuhPackagePassport_ins}").withReader { r ->
        def packageName = r.readLine()
        def folder
        while (folder = r.readLine()) {
            if (fixedScripts.contains(folder)) {
                content += "${folder}\n"
            }
        }
    }
    file("${workspaceBuild}/${updatesBuildDirectory}/${iuhPackagePassport_ins}").text = content

    //в паспорте update правим первую строчку (имя пакета) + добавляем пакет MigrateSQL
    List finalFolders = [updatesPackageDirectory]
    file("${workspaceBuild}/${updatesBuildDirectory}/${iuhPackagePassport_upd}").withReader { r ->
        def packageName = r.readLine()
        def folder
        while (folder = r.readLine()) {
            if (fixedScripts.contains(folder)) {
                finalFolders << folder
            }
        }
    }
    finalFolders << migrateGroovyDir

    //обновляем update-паспорт. он будет всегда (даже без пакетов, может состоять только из фикс. пакетов)
    packagePassport.delete()
    finalFolders.each { folderName ->
        packagePassport << "${folderName}\n"
    }

    Map result = [
        passportPath:   passportPath,
        specialFiles:   passports,
        specialFolders: fixedScripts
    ]
    return result
}

ext.sortSvnFiles = { Map map ->
    Map lastValue = [:]
    map.each { entry ->
        //сортируем все файлы в одном коммите в лексикографичеком порядке. Сортировка производится по именам sql файлов (без папок), поэтому
        //при коммите одновременно в ARM_Views и просто скрипта по багу в папку BR4J000XXXXX надо учитывать, что они отсортируются по имени,
        //так же как и при коммите нескольких файлов в одну папку BR4J000XXXXX.
        Map filesByRev = entry.value.sort { a,b -> a.key.split('/')[-1] <=> b.key.split('/')[-1] } ?: [:]

        //еще выносим скрипты для арма из папки ARM_Views в конец сортированного списка, чтобы арм выполнялся всегда после обычных скриптов
        Map arm = filesByRev.findAll {
            def fName = it.key
            fName.startsWith("ARM_Views")
        }
        Map br4j_first = filesByRev.findAll {
            def fName = it.key
            !fName.startsWith("ARM_Views")
        }
        
        filesByRev = [:]
        filesByRev.putAll(br4j_first)
        filesByRev.putAll(arm)

        //явные повторы убираем (следующие друг за другом одинаковые пачки скриптов)
        if (filesByRev && lastValue != filesByRev) {
            entry.value = filesByRev
            lastValue = filesByRev
        } else {
            entry.remove()
        }
    }

    //сортируем по возрастанию ревизий
    map = map.sort { a,b -> a.key - b.key }

    println '\n Сортированный окончательный список файлов и ревизий'
    map.each {
        println "${it.key}:"
        it.value.each {
            println "\t$it"
        }
    }
    println ''
    return map
}

//обработка собранных изменных файлов из нескольких источников (пока что trunk и конфигурации),
//а также модифицирование параметров для выкачивания этих файлов в сборный файл
ext.processResults = { Map resultParams, List maps ->
    //отбираем все не пустые и не null
    List listOfResults = maps.findAll { it }
    //если все оказались пустые или null то выходим, нечего обрабатывать
    if (!listOfResults) {
        return null
    }

    //мерджим полученные списки
    Map filesMap  = mergeFileMaps   (listOfResults*.files.findAll  { it })
    Map attachMap = mergeAttachMaps (listOfResults*.attach.findAll { it })
    
    //сортируем файлы
    filesMap = sortSvnFiles(filesMap)

    def toUrls   = listOfResults*.resolvedUrls*.toUrl.unique()
    def prevUrls = listOfResults*.resolvedUrls*.prevUrl.unique()
    Map urls     = [toUrls:toUrls, prevUrls:prevUrls, between:listOfResults*.resolvedUrls*.between?.first()]

    //обновляем значения параметров для выкачивания файлов
    resultParams.files  = filesMap
    resultParams.attach = attachMap
    resultParams.urls   = urls

    return resultParams
}

//функция для собирания по ревизиям migrate.sql и readme
ext.getFileListFromSVN = { Map params ->
    def result  = resolveUrls(params)
    if (!result) {
        println '==============================='
        println '!!! Нечего собирать. Выход. !!!'
        println '==============================='
        return null
    }
    def repoUrl = result.repoUrl
    def prevUrl = result.prevUrl
    def from    = result.from
    def to      = result.to
    def between = result.between
    
    println "repoUrl: ${repoUrl}"
    println "prevUrl: ${prevUrl}"
    println "Откуда начинаем собирать изменения : ${from}"
    println "До куда собираем изменения         : ${to}"

    def fromUrl = SVNURL.parseURIEncoded(from)
    def toUrl   = SVNURL.parseURIEncoded(to)
    if (prevUrl) {
        prevUrl = SVNURL.parseURIEncoded(prevUrl)
    }

    //получаем диапазон ревизий для заданных URL'ов (откуда собираем и докуда)
    def revisionFrom = getUrlRevision(fromUrl)
    def revisionTo   = getUrlRevision(toUrl)
    println " Начальная ревизия для ${params.projectUrl} = $revisionFrom"
    println " Конечная  ревизия для ${params.projectUrl} = $revisionTo"

    if (revisionFrom == null && revisionTo == null) {
        println "=================================="
        println "!!! '${params.projectUrl}' не существует. Выход. !!!"
        println "=================================="
        return null
    }

    List diffFiles      = []  //сюда собираем сами различающиеся файлы
    Map diffFilesAttach = [:] //сюда собираем приложенные к ним файлы (всякие .zip, или может .csv какие-нибудь)
    println '\n Измененные файлы:'

    List extensionsForScan = params.scanFilesExtensions.trim().split('( )+')
    boolean isGroovyType = params.type == "groovy"

    def isIgnored = { def value ->
        boolean isIgnored = params.ignore.any { ignoredName ->
            value.contains(ignoredName)
        }
        boolean isSpecial = params.fixedFolders.any { ignoredName ->
            value.contains(ignoredName)
        }
        if (isIgnored) {
            println "IGNORED: $value"
        }
        if (isSpecial) {
            println "SPECIAL: $value"
        }
        return isIgnored || isSpecial
    }

    //проект уже существовал, тогда собираем дифф между ветками
    if (revisionFrom && revisionTo) {
        diffClient.doDiffStatus(toUrl, SVNRevision.HEAD, fromUrl, 
            SVNRevision.HEAD, SVNDepth.INFINITY, true, 
            { SVNDiffStatus diffStatus ->
                def type = diffStatus.modificationType
                if (diffStatus.modificationType == SVNStatusType.STATUS_DELETED)
                    type = SVNStatusType.STATUS_ADDED
                else if (diffStatus.modificationType == SVNStatusType.STATUS_ADDED)
                    type = SVNStatusType.STATUS_DELETED
                println ("\t${type} - ${diffStatus.URL}")
                //тип модификации (изменен, добавлен, удален и т.д.) Нам не нужны добавления, т.к. DIFF мы смотрим
                //с последней ревизии по начальную (задом наперед, так уж пришлось) и если там показано что файл удален,
                //значит он на самом деле был добавлен, и наоборот. 
                //Удаленные файлы мы не выкачиваем.
                def deleted = diffStatus.modificationType == SVNStatusType.STATUS_ADDED
                if (diffStatus.kind == SVNNodeKind.FILE && !deleted) {
                    if (!isIgnored(diffStatus.path)) {
                        boolean endsWithScanExtension = extensionsForScan.any { scanExt ->
                            diffStatus.path.endsWith (scanExt)
                        }
                        if (endsWithScanExtension) {
                            diffFiles << diffStatus
                            if (isGroovyType) {
                                diffFilesAttach[diffStatus.path] = toUrl
                            }
                        } else {
                            diffFilesAttach[diffStatus.path] = toUrl
                        }
                    }
                }
            } as ISVNDiffStatusHandler
        )
    } else {
        //а тут проекта раньше не было, а в новом запрошенном патче (сборке) появился
        //тогда берем все содержимое этого проекта
        println '============= USING logClient.doList ================'
        SVNRevision svnRev = SVNRevision.create(revisionTo)
        logClient.doList(
            //params: url, pegRevision, revision, fetchLocks, depth, entryFields, handler
            toUrl, SVNRevision.UNDEFINED, svnRev, true, SVNDepth.INFINITY, SVNDirEntry.DIRENT_ALL, 
            { dirEntry ->
                def path = dirEntry.relativePath
                if (dirEntry.kind == SVNNodeKind.FILE) {
                    if (!isIgnored(path)) {
                        boolean endsWithScanExtension = extensionsForScan.any { scanExt ->
                            path.endsWith (scanExt)
                        }
                        if (endsWithScanExtension) {
                            diffFiles << dirEntry
                            if (isGroovyType) {
                                diffFilesAttach[path] = toUrl
                            }
                        } else {
                            diffFilesAttach[path] = toUrl
                        }
                    }
                }
            } as ISVNDirEntryHandler
        )

        //определяем ревизию когда проект впервые появился в текущей релизной ветке
        logClient.doLog(toUrl, null, 
                        SVNRevision.UNDEFINED, 
                        SVNRevision.create(0), 
                        SVNRevision.create(revisionTo), 
                        //stopOnCopy, discoverChangedPaths, includeMergedRevisions, limit, props
                        true, false, false, 1, null, 
                        { logEntry ->
                            if (logEntry.revision > 0) {
                                revisionFrom = logEntry.revision - 1
                            }
                        } as ISVNLogEntryHandler
        )
        println "============= Found revisionFrom: ${revisionFrom} ================"
    }

    def fileRevision = [:]
    //если есть измененные файлы
    if (diffFiles || diffFilesAttach) {
        
		//мапа файлов не попавших в итоговую выборку
        Map notIncludedFiles = [:]
        //получаем ревизии, когда файлы были добавлены (модифицированы, удалены) в релизной ветке (через лог SVN)
        println '\n Измененные файлы и ревизии их изменений в ветке релиза:'

        diffFiles.each { diffStatus ->
            println "\n${diffStatus.URL}"

            //если собираем для патчей то исключаем ревизии мерджей из транка в релизную ветку
            //(оставляем только реальные коммиты этого файла в транке)
            def excludeRevs = []
            if (patchNum != null) {
                println '\n\t  Ревизии мерджей в релизную ветку'
                logClient.doLog(diffStatus.URL, null, 
                                SVNRevision.UNDEFINED, 
                                SVNRevision.create(revisionFrom+1), 
                                SVNRevision.create(revisionTo), 
                                //stopOnCopy, discoverChangedPaths, includeMergedRevisions, limit, props
                                true, false, false, -1, null, 
                                { logEntry ->
                                    println("\t${logEntry.revision} (${logEntry.date})")
                                    if (logEntry.revision > 0) {
                                        excludeRevs << logEntry.revision
                                    }
                                } as ISVNLogEntryHandler
                )
                println '\t------------------------------------'
            }
			
			//помечаем текущий файл как невключенный в сборку\патч
            notIncludedFiles[diffStatus.URL] = false
			
            println '\t  Все ревизии измененных файлов'
            logClient.doLog(diffStatus.URL, null, 
                            SVNRevision.UNDEFINED, 
                            SVNRevision.create(revisionFrom+1), 
                            SVNRevision.create(revisionTo),
                            //stopOnCopy, discoverChangedPaths, includeMergedRevisions, limit, props
                            false, false, true, -1, null, 
                            { logEntry ->
                                if (logEntry.revision > 0) {
                                    print("\t${logEntry.revision} (${logEntry.date})")
                                    Map filePaths = fileRevision[logEntry.revision] ?: [:]
                                    if (!excludeRevs.contains(logEntry.revision)) {
                                        filePaths[diffStatus.path] = toUrl
                                        filePaths = filePaths.sort { a, b -> a.key <=> b.key}
                                        fileRevision[logEntry.revision] = filePaths
										
										//ревизия файла зафиксирована сборщиком, помечаем как попавший в выборку
                                        notIncludedFiles[diffStatus.URL] = true
                                        println " - included"
                                    } else {
                                        println ""
                                    }
                                    if (logEntry.hasChildren()) {
                                        println "\t\thas children"
                                    }
                                }
                            } as ISVNLogEntryHandler
            )
        }
		
		//создаем лог файл для текущей задачи
        def logFile = file("${logsDir}/skipped/${params.destFile}.log")
        logFile.parentFile.mkdirs()
        logFile.delete()

        //1. собираем только непопавшие файлы (со значением false)
        //2. выбираем только имя (url) файла
        //3. пишем в лог полученное имя
        notIncludedFiles.findAll { entry ->
        	entry.value == false
        }.collect { entry ->
			entry.key
        }.each { skippedFile ->
            logFile << skippedFile << '\n'    
        }

        fileRevision = fileRevision.sort { a, b -> a.key - b.key}
        println '\n Предварительный список файлов и ревизий'
        fileRevision.each {
            println "${it.key}:"
            it.value.each {
                println "\t$it"
            }
        }

        println '\n Подгружаем файлы, находящиеся в одной папке вместе с измененным файлом'
        fileRevision.each { def entry ->
            def markedFolders = []
            def files = [:]
            def curRevision = entry.key
            entry.value.each { def innerEntry ->
                def el = innerEntry.key
                def folder = el.split('/')[0..-2].join('/')
                def armViews = folder.startsWith("ARM_Views")
                if (!markedFolders.contains(folder) && !armViews) {
                    markedFolders << folder
                    print "\tПапка: ${folder}. ${entry.key} - "
                    try {
                        def filesInSameFolder = getSvnList(SVNURL.parseURIEncoded("${toUrl}/${folder}"), curRevision, '', 1).keySet().sort()
                        println "${filesInSameFolder}"
                        filesInSameFolder.findAll { e -> 
                            e.endsWith("${params.scanFilesExtensions}") 
                        }.collect { e -> 
                            "${folder}/${e}"
                        }.each { e ->
                            if (e) {
                                files[e] = toUrl
                            }
                        }

                        filesInSameFolder.findAll { e -> 
                            !e.endsWith("${params.scanFilesExtensions}") 
                        }.collect { e -> 
                            "${folder}/${e}"
                        }.each { e ->
                            if (e) {
                                diffFilesAttach[e] = toUrl
                            }
                        }
                    } catch (Exception e) {
                        println "\n\terror: ${e.message}"
                    }
                }
                if (armViews) { //sql скрипты из ArmViews
                    files[el] = toUrl
                }
            }
        }
    } else {
        println "==================${'='*params.projectUrl.size()}=="
        println "| Нет изменений в ${params.projectUrl} |"
        println "==================${'='*params.projectUrl.size()}=="
    }
    Map collectedResult = [
        files:  fileRevision, 
        attach: diffFilesAttach, 
        resolvedUrls: [
            toUrl:   toUrl, 
            prevUrl: prevUrl, 
            between: between
        ]
    ]
}

ext.getFilesFromSVN = { Map params ->
    //параметры пусты - выход
    if (!params) {
        return
    }

    Map urls       = params.urls
    List toUrls    = urls.toUrls
    def prevUrl    = urls.prevUrls[0]
    def between    = urls.between
    def fileList   = params.files
    def attachList = params.attach
    //Получаем доступ к репозиторию, чтобы выкачать оттуда необходимые файлы
    Map repos = [:]
    toUrls.each { projectUrl ->
        repos[projectUrl] = clientManager.createRepository(projectUrl, false)
    }

    //Записываем содержимое в один сводный файл
    def noteFile 
    if (params.type == "groovy") {
        noteFile = file("${params.passportFile}")
    } else if (params.type == "txt") {
        noteFile = file("${workspaceBuild}/${params.destDir}/${params.destFile}_${between}${params.scanFilesExtensions}")
    } else if (params.type == "sql") {
        noteFile = file("${workspaceBuild}/${params.destDir}/${params.destFile}${params.scanFilesExtensions}")
    }
    def preSql   = file("sql/pre.sql")
    def postSql  = file("sql/post.sql")
    if (!noteFile.exists()) {
        noteFile.parentFile.mkdirs()
        noteFile.delete()
    }
    if (params.type == "sql") {
        if (patchNum) {
            noteFile << preSql.text.replace("_svn.begin_", "${getUrlRevision(tagReleaseBuildSvnUrl)}") << '\n'
        } else {
            noteFile << preSql.text.replace("_svn.begin_", "${getUrlRevision(prevUrl)}") << '\n'
        }
    }

    //подгружаем список патчей и ревизий когда они были созданы
    def patchList = getSvnList(tagReleaseSvnUrl) ?: [:]
    patchList = patchList.sort { a,b -> a.value - b.value }
    patchList.each {
        println "${it.key}:"
        it.value = getPatchRealRevision(it.key)
    }
    println ''

    if (params.type != "groovy") {
        noteFile.withWriterAppend { out ->
            //список уже напечатанных отбивок по патчам, чтобы не 
            //печатать одну и ту же отбивку на каждый коммит
            def printedPatchSeparator = []
            fileList.each { it ->
                if (patchNum && patchList) {
                    def underPatch = patchList.find { el ->
                        it.key < el.value['release']
                    }.key
                    out << "\n"
                    if (!printedPatchSeparator.contains(underPatch)) {
                        printedPatchSeparator << underPatch
                        out << "/**** Patch $underPatch ****/\n"
                    }
                }
                if (params.type == "sql") {
                    out << "SELECT dbm_install_script(${it.key}, '"
                }
                it.value.each { entry ->
                    def tempFile = File.createTempFile('tempDownload','dwnld')
                    def fos = new FileOutputStream(tempFile)
                    try {
                        def fName   = entry.key
                        def project = entry.value
                        repos[project].getFile(fName, -1, null, fos)
                        out << "\n/*=======================================================*/"
                        out << "\n/**** $fName ****/\n"
                        def fis = new BOMInputStream(new FileInputStream(tempFile))
                        String content = fis.text
                        if (params.type == "sql") {
                            out << content.replaceAll("'","''")
                        } else {
                            out << content
                        }
                        out << "\n"
                    } catch (Exception e) {
                        println "error: ${e.message}"
                    } finally {
                        IOUtils.closeQuietly(fos)
                        tempFile.delete()
                    }
                }
                if (params.type == "sql") {
                    out << "--@UNDO');\n"
                }
            }
        }
        if (params.type == "sql") {
            noteFile << postSql.text.replace("_svn.end_","${patchList[patchNum?:'release']['tag']} (${releaseCode})")
        }
    } else  {
        noteFile.withWriterAppend { out ->
            def lastPackage = ''
            fileList.each { entry ->
                entry.value.each { svnUrl ->
                    def packageName = svnUrl.key.split('/')[0]
                    //непосредственные повторы пакетов друг за другом убираем
                    if (lastPackage != packageName) {
                        out << "${packageName}\n"
                        lastPackage = packageName
                    }
                }
            }
        }
    }

    if (attachList) {
        println "--> AttachList:"
        attachList.each {
            println "\t${it}"
        }
        println "--> Собираем прикрепленные дополнительные файлы. Количество - ${attachList.size()}"
        attachList.each { entry ->
            def attach = entry.key
            println "\t${attach}"
            noteFile = file("$workspaceBuild/${params.destDir}/${attach}")
            noteFile.parentFile.mkdirs()
            if (!noteFile.isDirectory()) {
                def fos = new FileOutputStream(noteFile)
                try {
                    repos[entry.value].getFile(attach, -1, null, fos)
                } catch (Exception e) {
                    println "error: ${e.message}"
                    noteFile.delete()
                } finally {
                    fos.close()
                }
            }
        }
        //очищаем пустые папки (остатки невыкачанных файлов)
        delEmptyDirs(file("$workspaceBuild/${params.destDir}"))
    } else {
        println '============================'
        println '| Прикрепленных файлов нет |'   
        println '============================'
    }
    println "===================================="
}

task cleanSrc << {
    println "Удаляем старые конфигурации из $workspaceConf"
    file(workspaceConf).deleteDir()
    println "Удаляем старые исходники из $workspaceSrc"
    file(workspaceSrc).deleteDir()
    println "Удаляем скачанные папки релизов (для пропертей) из $workspaceRls"
    file(workspaceRls).deleteDir()
}

task cleanBuild << {
    println "Удаляем старую сборку из $workspaceBuild"
    file(workspaceBuild).deleteDir()
    println "Удаляем старый артефакт из $workspaceArch"
    file(workspaceArch).deleteDir()
}